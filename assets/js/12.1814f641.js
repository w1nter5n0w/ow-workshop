(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{201:function(v,_,t){"use strict";t.r(_);var a=t(0),r=Object(a.a)({},function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"持续事件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#持续事件","aria-hidden":"true"}},[v._v("#")]),v._v(" 持续事件")]),v._v(" "),t("p",[v._v("目前为止，有“持续 - 全局”和“持续 - 每名玩家”两个持续事件。它们有一些难以把握。官方说：“当首次检查就满足条件时，则会执行行动。当未满足条件列表，但之后又满足时，则会尝试再次执行行动”。")]),v._v(" "),t("p",[v._v("我们举一些例子，来看看持续事件到底怎么回事。")]),v._v(" "),t("h2",{attrs:{id:"只运行一次"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#只运行一次","aria-hidden":"true"}},[v._v("#")]),v._v(" 只运行一次")]),v._v(" "),t("p",[v._v("使用持续事件但不附加任何条件，它在一次游戏中只会运行一次。你可以借此实现初始化。")]),v._v(" "),t("h2",{attrs:{id:"结合“循环”多次运行"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#结合“循环”多次运行","aria-hidden":"true"}},[v._v("#")]),v._v(" 结合“循环”多次运行")]),v._v(" "),t("p",[v._v("例如，我们想追踪玩家位置，如果玩家的Z坐标大于100，我们就每秒给玩家恢复100点生命值：")]),v._v(" "),t("p",[v._v("事件")]),v._v(" "),t("ul",[t("li",[v._v("持续 - 每名玩家")])]),v._v(" "),t("p",[v._v("条件")]),v._v(" "),t("ul",[t("li",[v._v("Z方向分量(位置(事件玩家)) > 100")])]),v._v(" "),t("p",[v._v("动作")]),v._v(" "),t("ul",[t("li",[v._v("等待(1, 无视条件)")]),v._v(" "),t("li",[v._v("治疗(事件玩家, 无, 100)")]),v._v(" "),t("li",[v._v("如条件为“真”则循环")])]),v._v(" "),t("p",[v._v("如果没有"),t("code",[v._v("如条件为“真”则循环")]),v._v("，那么便达不到我们的目的，因为条件并没有从满足变为不满足再变为满足，规则就只会运行一次。")]),v._v(" "),t("h2",{attrs:{id:"根据条件多次运行"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#根据条件多次运行","aria-hidden":"true"}},[v._v("#")]),v._v(" 根据条件多次运行")]),v._v(" "),t("p",[v._v("例如，我们想追踪玩家位置，如果玩家的Z坐标大于100，我们就在3秒后将玩家移动到某个位置：")]),v._v(" "),t("p",[v._v("事件")]),v._v(" "),t("ul",[t("li",[v._v("持续 - 每名玩家")])]),v._v(" "),t("p",[v._v("条件")]),v._v(" "),t("ul",[t("li",[v._v("Z方向分量(位置(事件玩家)) > 100")])]),v._v(" "),t("p",[v._v("动作")]),v._v(" "),t("ul",[t("li",[v._v("等待(3, 无视条件)")]),v._v(" "),t("li",[v._v("传送(事件玩家, 矢量(0, 0, 0))")])]),v._v(" "),t("p",[v._v("这个规则能达到我们的目的，但它是有问题的：如果一个玩家在Z=100的地方进进出出（即一会儿小于100，一会儿又大于100），那么玩家就会被多次传送。原因是，“当未满足条件列表，但之后又满足时，则会尝试再次执行行动”。这种情况叫“抖动”。")]),v._v(" "),t("p",[v._v("解决方法有两个，最简单的便是把等待改成"),t("code",[v._v("等待(3, 当为“假”时中止)")]),v._v("。这是最简单的，但不一定适合所有情况。我们在这里介绍一种比较通用的方法：做一个“锁”。假设我们需要：玩家首次进入Z>100的范围，3s后传送。那么，我们可以这样写动作：")]),v._v(" "),t("ul",[t("li",[v._v("根据条件跳过(玩家变量(事件玩家, C), 1)")]),v._v(" "),t("li",[v._v("中止")]),v._v(" "),t("li",[v._v("设置玩家变量(事件玩家, C, 真)")]),v._v(" "),t("li",[v._v("等待(3, 无视条件)")]),v._v(" "),t("li",[v._v("传送(事件玩家, 矢量(0, 0, 0))")]),v._v(" "),t("li",[v._v("设置玩家变量(事件玩家, C, 假)")])]),v._v(" "),t("p",[v._v("这里的玩家变量C变成为了一个“锁”。如果我们没有拿到锁，那么这条规则直接中止。否则才会向下执行。在传送完后，再把“锁”释放掉，让别人能“再来一次”。")])])},[],!1,null,null,null);_.default=r.exports}}]);